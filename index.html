<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <!-- âœ… æ‰‹æ©Ÿ/å¹³æ¿ï¼šæ­£ç¢º viewport + iPhone/iPad å®‰å…¨å€ -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Starter å–®å­—éŠæˆ²ï¼ˆCanvas å‹•ç•«ç‰ˆï½œæ‰‹æ©Ÿ/å¹³æ¿å„ªåŒ–ï¼‰</title>
  <style>
    :root{
      --bg:#0b0f16;
      --text:#e9eef8;
      --muted:rgba(233,238,248,.65);
      --line:rgba(255,255,255,.08);
      --panel1:rgba(255,255,255,.06);
      --panel2:rgba(255,255,255,.10);

      /* è‡ªé©æ‡‰å­—ç´š/é–“è·ï¼šæ‰‹æ©Ÿä¸æ“ ã€å¹³æ¿ä¸ç©º */
      --pad: clamp(10px, 2.8vw, 16px);
      --gap: clamp(8px, 2.2vw, 12px);
      --font: clamp(14px, 3.2vw, 16px);
      --control: clamp(40px, 9.5vw, 48px); /* æ§åˆ¶å…ƒä»¶é«˜åº¦ï¼ˆå¥½é»ï¼‰ */
      --radius: 14px;
    }

    html,body{
      height:100%; margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,"Noto Sans TC",sans-serif;
      -webkit-text-size-adjust:100%;
    }

    /* âœ… iPhone ç€æµ·/åº•éƒ¨æ‰‹å‹¢å®‰å…¨å€ */
    body{
      padding:
        env(safe-area-inset-top)
        env(safe-area-inset-right)
        env(safe-area-inset-bottom)
        env(safe-area-inset-left);
      box-sizing:border-box;
      overflow:hidden; /* ä»¥ canvas äº’å‹•ç‚ºä¸»ï¼Œé¿å…æ•´é äº‚æ»‘ */
    }

    .wrap{
      display:flex;
      flex-direction:column;
      height:100%;
      min-height:100svh; /* iOS å‹•æ…‹å·¥å…·åˆ—å‹å–„ */
    }

    /* âœ… ä¸Šæ–¹æ§åˆ¶åˆ—ï¼šæ‰‹æ©Ÿæ”¹å…©è¡Œã€å¹³æ¿æ›´å¯¬é¬† */
    .topbar{
      position:sticky;
      top:0;
      z-index:10;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
      align-items:center;
      padding: var(--pad);
      border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    /* å¹³æ¿/æ©«å‘ï¼šå¤šæ¬„ */
    @media (min-width: 820px){
      .topbar{ grid-template-columns: repeat(6, minmax(0, 1fr)); }
      .topbar .span2{ grid-column: span 2; }
      .topbar .span3{ grid-column: span 3; }
    }

    .topbar > *{ font-size: var(--font); }

    select, button, input{
      height: var(--control);
      border:1px solid rgba(255,255,255,.16);
      background:var(--panel1);
      color:var(--text);
      padding: 0 12px;
      border-radius: var(--radius);
      outline:none;
      width:100%;
      box-sizing:border-box;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    label{
      display:flex;
      gap:8px;
      align-items:center;
      width:100%;
      min-width:0;
    }
    label > select{ flex:1; min-width:0; }

    /* checkbox label æœƒæ¯”è¼ƒæ“ ï¼Œç‰¹åˆ¥è™•ç† */
    label.chk{
      justify-content:flex-start;
      padding: 0 10px;
      border:1px solid rgba(255,255,255,.16);
      border-radius: var(--radius);
      background: var(--panel1);
      height: var(--control);
    }
    label.chk input{ width:auto; height:auto; }

    button{cursor:pointer; background:var(--panel2);}
    button:active{transform:scale(.98);}

    .pill{
      display:flex;
      align-items:center;
      justify-content:center;
      height: var(--control);
      padding: 0 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      font-variant-numeric:tabular-nums;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* âœ… Canvas å æ»¿å‰©é¤˜ç©ºé–“ */
    #stage{
      flex:1;
      display:block;
      width:100%;
      height:100%;
      touch-action: manipulation; /* é¿å…é›™æ“Šæ”¾å¤§ */
    }

    /* âœ… åº•éƒ¨è³‡è¨Šåˆ—ï¼šæ‰‹æ©Ÿå¯æ”¶åˆï¼Œé¿å…æ“‹ä½ç•«é¢ */
    .bottom{
      position:relative;
      padding: var(--pad);
      border-top:1px solid var(--line);
      background:linear-gradient(0deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
    }

    .muted{color:var(--muted); font-size: clamp(12px, 3vw, 13px); line-height:1.45;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px;}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace; padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06);}

    /* âœ… æ”¶åˆæ¨¡å¼ï¼šçµ¦æ‰‹æ©Ÿ/å¹³æ¿æ»¿ç‰ˆç© */
    .compact .bottom{ display:none; }

    /* âœ… è¶…å°è¢å¹•ï¼šä¸Šæ¬„æ”¹ 1 æ¬„ï¼Œé¿å…æ“ çˆ† */
    @media (max-width: 390px){
      .topbar{ grid-template-columns: 1fr; }
    }

    /* âœ… æ¸›å°‘å‹•æ…‹æ•ˆæœ */
    @media (prefers-reduced-motion: reduce){
      *{ transition:none !important; animation:none !important; }
    }
  </style>
</head>
<body>
<div class="wrap" id="appRoot">
  <div class="topbar">
    <label class="span2">é¡Œåº«ä¾†æº
      <select id="lexSource">
        <option value="builtin">å…§å»ºç¤ºç¯„</option>
        <option value="github_json" selected>åŒç›®éŒ„ words.json</option>
        <option value="upload">ä¸Šå‚³æª”æ¡ˆ</option>
      </select>
    </label>
    <input id="fileInput" type="file" accept=".json,.csv,text/csv,application/json" style="display:none;" />

    <label class="span2">ç« ç¯€ï¼ˆæ¯ 20 å–®ï¼‰
      <select id="chapter"></select>
    </label>

    <label class="span2">æ¨¡å¼
      <select id="mode">
        <option value="listen_pick">A è½è‹±æ–‡ â†’ é¸ä¸­æ–‡</option>
        <option value="cn_spell">B çœ‹ä¸­æ–‡ â†’ æ‹¼è‹±æ–‡</option>
      </select>
    </label>

    <label>é¡Œæ•¸
      <select id="qCount">
        <option>10</option><option>20</option><option selected>30</option><option>50</option>
      </select>
    </label>

    <label>é›£åº¦
      <select id="difficulty">
        <option value="easy">å®¹æ˜“</option>
        <option value="normal" selected>ä¸€èˆ¬</option>
        <option value="hard">å›°é›£</option>
      </select>
    </label>

    <label class="chk"><input id="autoSpeak" type="checkbox" checked />è‡ªå‹•å”¸è‹±æ–‡</label>

    <button id="startBtn">é–‹å§‹</button>
    <button id="retryWrongBtn">é‡è€ƒéŒ¯é¡Œ</button>
    <button id="speakBtn">ğŸ”Š å”¸ä¸€æ¬¡</button>
    <button id="showWrongBtn">æŸ¥çœ‹éŒ¯é¡Œ</button>
    <button id="resetStatsBtn">æ¸…é™¤æˆç¸¾</button>

    <!-- âœ… æ‰‹æ©Ÿ/å¹³æ¿ï¼šä¸€éµæ”¶åˆåº•éƒ¨è³‡è¨Šï¼ˆç•«é¢æ›´å¤§ï¼‰ -->
    <button id="compactBtn" title="æ”¶åˆ/å±•é–‹åº•éƒ¨èªªæ˜">ğŸ“± æ”¶åˆèªªæ˜</button>

    <span class="pill span3" id="statPill"></span>
    <span class="pill" id="wrongPill"></span>
  </div>

  <canvas id="stage"></canvas>

  <div class="bottom" id="bottomBar">
    <div class="muted">
      âœ… GitHub Pages é¡Œåº«å»ºè­°æ”¾ï¼š<span class="kbd">words.json</span>ï¼ˆèˆ‡ <span class="kbd">index.html</span> åŒç›®éŒ„ï¼‰ã€‚
      JSON æ ¼å¼ï¼š<span class="kbd">[{"en":"apple","zh":"è˜‹æœ","icon":"ğŸ"}, ...]</span>ï¼ˆUTF-8ï¼‰ã€‚
      ä½ ä¹Ÿå¯ä»¥åœ¨ JSON å…§åŠ å…¥ <span class="kbd">icon</span>ï¼ˆemojiï¼‰ç•¶ä½œæç¤ºåœ–ï¼›æ²’å¡«ä¹Ÿæœƒè‡ªå‹•çµ¦ç°¡å–®åœ–ç¤ºã€‚<br/>
      iOS/Safari è‹¥ç¬¬ä¸€æ¬¡ä¸å‡ºè²ï¼Œå…ˆæŒ‰ä¸€æ¬¡ã€ŒğŸ”Š å”¸ä¸€æ¬¡ã€è§£é–èªéŸ³/éŸ³æ•ˆã€‚
    </div>
    <div class="row">
      <button id="loadWordsBtn" style="width:auto;">è¼‰å…¥é¡Œåº«</button>
      <span class="muted" id="wordCount"></span>
      <span class="muted">ï¼ˆæ‹¼å­—æ¨¡å¼ï¼šæŒ‰ <span class="kbd">Enter</span> é€å‡ºï¼›æˆ–é»ç•«é¢ä¸Šçš„ã€Œç¢ºèªã€ï¼‰</span>
    </div>
  </div>
</div>

<script>
/* =========================
   0) å°å·¥å…·ï¼ˆâš ï¸ å¿…é ˆæ”¾åœ¨æœ€å‰é¢ï¼Œé¿å… TDZï¼‰
   ========================= */
const $ = (id)=>document.getElementById(id);
const normalize = (s)=> (s||"").trim().toLowerCase();

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutBack(t){
  const c1 = 1.70158, c3 = c1 + 1;
  return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
}

// âœ… æ”¶åˆ/å±•é–‹åº•éƒ¨èªªæ˜ï¼ˆæ‰‹æ©Ÿ/å¹³æ¿æ›´å¥½ç©ï¼‰
(function initCompactToggle(){
  const root = $("appRoot");
  const key = "starter_canvas_compact_v1";
  const saved = localStorage.getItem(key);
  if (saved === "1") root.classList.add("compact");
  $("compactBtn").addEventListener("click", ()=>{
    root.classList.toggle("compact");
    localStorage.setItem(key, root.classList.contains("compact") ? "1" : "0");
    // æ”¶åˆ/å±•é–‹å¾Œ canvas å°ºå¯¸æœƒè®Šï¼Œé‡æ–°è¨ˆç®—
    setTimeout(()=>{ resize(); layout(); }, 0);
  });
})();

// è‡ªå‹•çµ¦ç°¡å–®æç¤ºåœ–ï¼ˆä½ ä¹Ÿå¯ä»¥åœ¨ words.json è‡ªå·±å¡« iconï¼‰
const ICON_MAP = {
  apple:"ğŸ", banana:"ğŸŒ", orange:"ğŸŠ", grape:"ğŸ‡", pear:"ğŸ", lemon:"ğŸ‹", strawberry:"ğŸ“",
  cat:"ğŸ±", dog:"ğŸ¶", bird:"ğŸ¦", fish:"ğŸŸ", duck:"ğŸ¦†", rabbit:"ğŸ°", bear:"ğŸ»", tiger:"ğŸ¯", lion:"ğŸ¦", elephant:"ğŸ˜", mouse:"ğŸ­",
  book:"ğŸ“˜", pen:"ğŸ–Šï¸", pencil:"âœï¸", ruler:"ğŸ“", bag:"ğŸ’", school:"ğŸ«", teacher:"ğŸ§‘â€ğŸ«", student:"ğŸ§’",
  car:"ğŸš—", bus:"ğŸšŒ", train:"ğŸš†", bike:"ğŸš²", airplane:"âœˆï¸", ship:"ğŸš¢",
  water:"ğŸ’§", drink:"ğŸ¥¤", milk:"ğŸ¥›", juice:"ğŸ§ƒ", eat:"ğŸ½ï¸", bread:"ğŸ", rice:"ğŸš",
  sun:"â˜€ï¸", moon:"ğŸŒ™", star:"â­", cloud:"â˜ï¸", rain:"ğŸŒ§ï¸", snow:"â„ï¸",
  red:"ğŸ”´", blue:"ğŸ”µ", green:"ğŸŸ¢", yellow:"ğŸŸ¡", black:"âš«", white:"âšª",
  happy:"ğŸ˜„", sad:"ğŸ˜¢", angry:"ğŸ˜ ", smile:"ğŸ˜Š",
  family:"ğŸ‘ª", mom:"ğŸ‘©", mother:"ğŸ‘©", dad:"ğŸ‘¨", father:"ğŸ‘¨",
  run:"ğŸƒ", walk:"ğŸš¶", jump:"ğŸ¦˜", swim:"ğŸŠ",
};
function autoIcon(w){
  const en = normalize(w?.en);
  if (en && ICON_MAP[en]) return ICON_MAP[en];
  if (/cat|kitty/.test(en)) return "ğŸ±";
  if (/dog|puppy/.test(en)) return "ğŸ¶";
  if (/book|read/.test(en)) return "ğŸ“˜";
  if (/pen|pencil/.test(en)) return "âœï¸";
  if (/school/.test(en)) return "ğŸ«";
  if (/car/.test(en)) return "ğŸš—";
  if (/train/.test(en)) return "ğŸš†";
  if (/bus/.test(en)) return "ğŸšŒ";
  if (/air|plane/.test(en)) return "âœˆï¸";
  if (/sun/.test(en)) return "â˜€ï¸";
  if (/moon/.test(en)) return "ğŸŒ™";
  if (/rain/.test(en)) return "ğŸŒ§ï¸";
  if (/snow/.test(en)) return "â„ï¸";
  if (/red/.test(en)) return "ğŸ”´";
  if (/blue/.test(en)) return "ğŸ”µ";
  if (/green/.test(en)) return "ğŸŸ¢";
  if (/yellow/.test(en)) return "ğŸŸ¡";
  if (/happy/.test(en)) return "ğŸ˜„";
  if (/sad/.test(en)) return "ğŸ˜¢";
  return "â­";
}

function addAutoIcons(list){
  return (list||[]).map(w=>({ ...w, icon: (w.icon && String(w.icon).trim()) ? String(w.icon).trim() : autoIcon(w) }));
}

/* =========================
   1) åˆå§‹ç¤ºç¯„é¡Œåº«
   ========================= */
let BUILTIN_WORDS = [
  {en:"apple", zh:"è˜‹æœ", icon:"ğŸ"},
  {en:"banana", zh:"é¦™è•‰", icon:"ğŸŒ"},
  {en:"cat", zh:"è²“", icon:"ğŸ±"},
  {en:"dog", zh:"ç‹—", icon:"ğŸ¶"},
  {en:"book", zh:"æ›¸", icon:"ğŸ“˜"},
  {en:"pen", zh:"ç­†", icon:"ğŸ–Šï¸"},
  {en:"school", zh:"å­¸æ ¡", icon:"ğŸ«"},
  {en:"teacher", zh:"è€å¸«", icon:"ğŸ§‘â€ğŸ«"},
  {en:"student", zh:"å­¸ç”Ÿ", icon:"ğŸ§’"},
  {en:"happy", zh:"é–‹å¿ƒçš„", icon:"ğŸ˜„"},
  {en:"sad", zh:"é›£éçš„", icon:"ğŸ˜¢"},
  {en:"big", zh:"å¤§çš„", icon:"ğŸ˜"},
  {en:"small", zh:"å°çš„", icon:"ğŸ­"},
  {en:"run", zh:"è·‘", icon:"ğŸƒ"},
  {en:"walk", zh:"èµ°", icon:"ğŸš¶"},
  {en:"drink", zh:"å–", icon:"ğŸ¥¤"},
  {en:"eat", zh:"åƒ", icon:"ğŸ½ï¸"},
  {en:"red", zh:"ç´…è‰²", icon:"ğŸ”´"},
  {en:"blue", zh:"è—è‰²", icon:"ğŸ”µ"},
  {en:"family", zh:"å®¶åº­", icon:"ğŸ‘ª"}
];

let WORDS = addAutoIcons(BUILTIN_WORDS.slice());

/* =========================
   2) å„²å­˜ï¼ˆæˆç¸¾ + éŒ¯é¡Œ + æœ€å¾Œé¡Œåº«ï¼‰
   ========================= */
const STATS_KEY = "starter_canvas_stats_v3";
const WRONG_KEY = "starter_canvas_wrong_v3";
const WORDS_KEY = "starter_canvas_words_v3";

let stats = JSON.parse(localStorage.getItem(STATS_KEY) || "{}");
if (!stats.total) stats = {total:0, correct:0, streak:0, bestStreak:0};

let wrongMap = JSON.parse(localStorage.getItem(WRONG_KEY) || "{}");

function saveStats(){ localStorage.setItem(STATS_KEY, JSON.stringify(stats)); renderPills(); }
function saveWrong(){ localStorage.setItem(WRONG_KEY, JSON.stringify(wrongMap)); renderPills(); }

function renderPills(){
  const acc = stats.total ? Math.round(stats.correct/stats.total*100) : 0;
  $("statPill").textContent = `ç¸½é¡Œ ${stats.total}ï½œæ­£ç¢º ${stats.correct}ï½œæ­£ç¢ºç‡ ${acc}%ï½œé€£å° ${stats.streak}ï½œæœ€é«˜ ${stats.bestStreak}`;
  $("wrongPill").textContent = `éŒ¯é¡Œæœ¬ ${Object.keys(wrongMap).length} é¡Œï½œé¡Œåº« ${WORDS.length} çµ„`;
}
renderPills();

function addWrong(word){
  const k = normalize(word.en);
  if (!wrongMap[k]) wrongMap[k] = {en:word.en, zh:word.zh, icon:word.icon||autoIcon(word), wrongCount:0, lastAt:""};
  wrongMap[k].wrongCount += 1;
  wrongMap[k].lastAt = new Date().toISOString();
  saveWrong();
}
function removeWrongIfExists(word){
  const k = normalize(word.en);
  if (wrongMap[k]) { delete wrongMap[k]; saveWrong(); }
}
function getWrongList(){
  return Object.values(wrongMap).sort((a,b)=>(b.wrongCount||0)-(a.wrongCount||0));
}

/* =========================
   3) é¡Œåº«è¼‰å…¥ï¼ˆä¾†æºé¸æ“‡ï¼‰
   ========================= */
function validateWordList(list){
  if (!Array.isArray(list)) return null;
  const cleaned = list
    .map(x => ({
      en: String(x.en||"").trim(),
      zh: String(x.zh||"").trim(),
      icon: (x.icon==null? "" : String(x.icon).trim())
    }))
    .filter(x => x.en && x.zh);
  return cleaned.length >= 4 ? cleaned : null;
}

function parseCsvToWords(text){
  // æ”¯æ´ï¼šen,zh,icon(å¯çœç•¥)
  const lines = (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const list = [];
  for (const line of lines){
    const parts = line.split(",");
    const en = (parts[0]||"").trim();
    const zh = (parts[1]||"").trim();
    const icon = (parts[2]||"").trim();
    if (en && zh) list.push({en, zh, icon});
  }
  return list;
}

let CHAPTERS = [];
function chunkIntoChapters(words, size=20){
  const out = [];
  for (let i=0;i<words.length;i+=size){
    out.push({
      index: out.length,
      start: i,
      end: Math.min(i+size, words.length),
      words: words.slice(i, i+size)
    });
  }
  return out;
}

function populateChapterSelect(){
  const sel = $("chapter");
  if (!sel) return;
  const prev = sel.value;
  sel.innerHTML = "";

  const optAll = document.createElement("option");
  optAll.value = "all";
  optAll.textContent = `å…¨éƒ¨ï¼ˆ${WORDS.length}ï¼‰`;
  sel.appendChild(optAll);

  CHAPTERS.forEach(ch=>{
    const o = document.createElement("option");
    o.value = String(ch.index);
    const a = ch.start + 1;
    const b = ch.end;
    o.textContent = `ç¬¬ ${ch.index+1} ç« ï¼š${a}â€“${b}ï¼ˆ${ch.words.length}ï¼‰`;
    sel.appendChild(o);
  });

  if (prev && [...sel.options].some(o=>o.value===prev)) sel.value = prev;
  else sel.value = "all";
}

function selectedChapterWords(){
  const sel = $("chapter");
  if (!sel) return WORDS;
  if (sel.value === "all") return WORDS;
  const idx = parseInt(sel.value,10);
  if (Number.isFinite(idx) && CHAPTERS[idx]) return CHAPTERS[idx].words;
  return WORDS;
}

function updateWordCount(){
  CHAPTERS = chunkIntoChapters(WORDS, 20);
  populateChapterSelect();
  const sel = $("chapter");
  const chosen = (sel && sel.value!=="all" && CHAPTERS[parseInt(sel.value,10)])
    ? CHAPTERS[parseInt(sel.value,10)].words.length
    : WORDS.length;
  $("wordCount").textContent = `ç›®å‰é¡Œåº«ï¼š${WORDS.length} çµ„ï½œç« ç¯€ï¼š${CHAPTERS.length} ç« ï½œç›®å‰é¸ç”¨ï¼š${chosen} çµ„`;
  renderPills();
}
updateWordCount();

async function loadWordsFromSource(){
  const src = $("lexSource").value;

  if (src === "builtin"){
    WORDS = addAutoIcons(BUILTIN_WORDS.slice());
    localStorage.setItem(WORDS_KEY, JSON.stringify({source:"builtin", words:WORDS}));
    toast("ä½¿ç”¨å…§å»ºç¤ºç¯„é¡Œåº«");
    updateWordCount();
    return;
  }

  if (src === "github_json"){
    try{
      const res = await fetch("./words.json", { cache:"no-store" });
      if (!res.ok) throw new Error("fetch failed: " + res.status);
      const data = await res.json();
      const list = validateWordList(data);
      if (!list) throw new Error("bad format");
      WORDS = addAutoIcons(list);
      localStorage.setItem(WORDS_KEY, JSON.stringify({source:"github_json", words:WORDS}));
      toast(`âœ… å·²å¾ words.json è¼‰å…¥ ${WORDS.length} çµ„`);
      updateWordCount();
    }catch(e){
      console.error(e);
      toast("âŒ è®€å– words.json å¤±æ•—ï¼šè«‹ç¢ºèªæª”æ¡ˆåœ¨åŒç›®éŒ„ä¸”æ ¼å¼æ­£ç¢º");
    }
    return;
  }

  if (src === "upload"){
    $("fileInput").click();
    return;
  }
}

$("fileInput").addEventListener("change", async ()=>{
  const f = $("fileInput").files?.[0];
  if (!f) return;

  try{
    const text = await f.text();
    let list = null;

    if (f.name.toLowerCase().endsWith(".json")){
      const data = JSON.parse(text);
      list = validateWordList(data);
    } else {
      const parsed = parseCsvToWords(text);
      list = validateWordList(parsed);
    }

    if (!list) throw new Error("bad list");

    WORDS = addAutoIcons(list);
    localStorage.setItem(WORDS_KEY, JSON.stringify({source:"upload", words:WORDS}));
    toast(`âœ… å·²å¾æª”æ¡ˆè¼‰å…¥ ${WORDS.length} çµ„`);
    updateWordCount();
  }catch(e){
    console.error(e);
    toast("âŒ æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼šJSON éœ€ç‚º [{en,zh,icon?}...] æˆ– CSV ç‚º en,zh,icon?");
  } finally {
    $("fileInput").value = "";
  }
});

(function restoreLastWords(){
  const saved = localStorage.getItem(WORDS_KEY);
  if (!saved) return;
  try{
    const obj = JSON.parse(saved);
    const list = validateWordList(obj.words);
    if (list){ WORDS = addAutoIcons(list); updateWordCount(); }
  }catch{}
})();

/* =========================
   4) éŸ³æ•ˆï¼ˆWebAudioï¼‰+ è‹±æ–‡ç™¼éŸ³
   ========================= */
let audioCtx = null;
function ensureAudio(){
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended") audioCtx.resume();
}
function beep({freq=440, dur=0.12, type="sine", gain=0.05}={}){
  ensureAudio();
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.setValueAtTime(freq, t);
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(gain, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  o.connect(g).connect(audioCtx.destination);
  o.start(t);
  o.stop(t+dur+0.02);
}
function sfxClick(){ beep({freq:520,dur:0.06,type:"triangle",gain:0.04}); }
function sfxCorrect(){
  beep({freq:660,dur:0.07,type:"sine",gain:0.05});
  setTimeout(()=>beep({freq:880,dur:0.09,type:"sine",gain:0.05}), 80);
}
function sfxWrong(){
  beep({freq:220,dur:0.12,type:"sawtooth",gain:0.05});
  setTimeout(()=>beep({freq:180,dur:0.14,type:"sawtooth",gain:0.05}), 110);
}
function speak(text){
  try{
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "en-US";
    u.rate = 0.9;
    u.pitch = 1.0;
    window.speechSynthesis.speak(u);
  }catch(e){}
}

/* =========================
   5) Canvasï¼šå…’ç«¥æ´»æ½‘èƒŒæ™¯ï¼ˆæ¼‚æµ®æ°£çƒ/æ³¡æ³¡/é›²æœµ/å½©è™¹å¸¶ï¼‰
   ========================= */
const canvas = $("stage");
const ctx = canvas.getContext("2d");
let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

function resize(){
  // âœ… é‡å° iOS å‹•æ…‹å·¥å…·åˆ—ï¼šå–å¯¦éš› canvas å¯è¦–å¤§å°
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
}

// iOS/iPad æ—‹è½‰æ™‚ï¼Œresize äº‹ä»¶æœ‰æ™‚æœƒå»¶é²ï¼Œè£œä¸€å€‹ orientationchange
window.addEventListener("resize", ()=>{ resize(); layout(); });
window.addEventListener("orientationchange", ()=>{ setTimeout(()=>{ resize(); layout(); }, 250); });
resize();

let tNow = 0;
let W=0,H=0;

// å…’ç«¥èƒŒæ™¯ç‰©ä»¶
let bg = { bubbles:[], clouds:[], confetti:[] };
function rand(a,b){ return a + Math.random()*(b-a); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function initBackground(){
  const W0 = canvas.width, H0 = canvas.height;
  bg.bubbles = [];
  bg.clouds = [];
  bg.confetti = [];

  const bubbleColors = [
    [255, 105, 180],
    [255, 193, 7],
    [76, 175, 80],
    [33, 150, 243],
    [156, 39, 176],
    [255, 87, 34]
  ];

  const nB = Math.floor(Math.min(26, Math.max(16, W0/60)));
  for (let i=0;i<nB;i++){
    const c = pick(bubbleColors);
    bg.bubbles.push({
      x: rand(0,W0),
      y: rand(0,H0),
      r: rand(14, 42) * DPR,
      vx: rand(-0.15, 0.15) * DPR,
      vy: rand(-0.35, -0.08) * DPR,
      wob: rand(0, Math.PI*2),
      wobSp: rand(0.6, 1.4),
      a: rand(0.10, 0.22),
      c
    });
  }

  const nC = 6;
  for (let i=0;i<nC;i++){
    bg.clouds.push({
      x: rand(-W0*0.2, W0*1.2),
      y: rand(H0*0.05, H0*0.32),
      s: rand(0.7, 1.35) * DPR,
      vx: rand(0.06, 0.14) * DPR,
      a: rand(0.08, 0.13)
    });
  }

  const nF = Math.floor(Math.min(80, Math.max(40, W0/20)));
  for (let i=0;i<nF;i++){
    const c = pick(bubbleColors);
    bg.confetti.push({
      x: rand(0,W0),
      y: rand(0,H0),
      w: rand(3, 7) * DPR,
      h: rand(6, 14) * DPR,
      vy: rand(0.10, 0.35) * DPR,
      vx: rand(-0.08, 0.08) * DPR,
      rot: rand(0, Math.PI*2),
      rotSp: rand(-1.2, 1.2),
      a: rand(0.10, 0.18),
      c
    });
  }
}

let particles = [];
function spawnParticles(x,y, good=true){
  const n = good ? 26 : 20;
  for (let i=0;i<n;i++){
    const a = Math.random()*Math.PI*2;
    const sp = (good? 2.8:2.2) + Math.random()*3.2;
    particles.push({
      x,y,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: 0,
      ttl: (good? 0.9:0.7) + Math.random()*0.35,
      r: (good? 2.2:2.0) + Math.random()*2.4,
      good
    });
  }
}

class UIButton{
  constructor({id, x,y,w,h, text, icon="", onClick, kind="normal"}){
    this.id=id; this.x=x; this.y=y; this.w=w; this.h=h;
    this.text=text; this.icon=icon; this.onClick=onClick;
    this.kind=kind;
    this.scale=1;
    this.pressT=0;
    this.disabled=false;
  }
  contains(px,py){ return px>=this.x && px<=this.x+this.w && py>=this.y && py<=this.y+this.h; }
  press(){ this.pressT=0.12; this.scale=0.96; }
  update(dt){
    if (this.pressT>0){
      this.pressT-=dt;
      const t = 1 - clamp(this.pressT/0.12,0,1);
      this.scale = lerp(0.96,1,easeOutBack(t));
    } else {
      this.scale = lerp(this.scale,1, clamp(dt*10,0,1));
    }
  }
  draw(){
    const {x,y,w,h, text, kind, disabled} = this;
    const cx = x+w/2, cy=y+h/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.scale(this.scale,this.scale);
    ctx.translate(-cx,-cy);

    const r=18;
    const bgFill = disabled ? "rgba(255,255,255,.05)" :
      (kind==="primary" ? "rgba(80,200,140,.22)" :
       kind==="danger" ? "rgba(255,80,120,.18)" :
       "rgba(255,255,255,.10)");
    const bd = disabled ? "rgba(255,255,255,.10)" :
      (kind==="primary" ? "rgba(120,240,170,.45)" :
       kind==="danger" ? "rgba(255,140,180,.40)" :
       "rgba(255,255,255,.22)");

    roundRect(x,y,w,h,r,bgFill,bd);

    ctx.fillStyle = disabled ? "rgba(233,238,248,.45)" : "rgba(233,238,248,.96)";

    if (this.icon){
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font = `900 ${Math.floor(28*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
      ctx.fillText(this.icon, cx, cy - 12*DPR);
      ctx.font = `800 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
      ctx.fillText(text, cx, cy + 16*DPR);
    } else {
      ctx.font = `800 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(text, cx, cy);
    }

    ctx.restore();
  }
}
function roundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  const rr = Math.min(r, w/2, h/2);
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
  ctx.fillStyle = fill;
  ctx.fill();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = 1.5*DPR;
  ctx.stroke();
}

/* =========================
   6) éŠæˆ²é‚è¼¯
   ========================= */
let quiz = [];
let idx = 0;
let current = null;
let phase = "idle";
let feedback = {text:"", good:true, t:0};
let shake = {t:0, mag:0};
let answerText = "";
let ui = {buttons:[]};

function shuffle(arr){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function pickN(arr, n){ return shuffle(arr).slice(0, Math.min(n, arr.length)); }

function similarPool(correctZh){
  const diff = $("difficulty").value;
  let pool = WORDS.filter(w=>w.zh!==correctZh);
  if (diff==="hard"){
    const targetLen = correctZh.length;
    pool = pool.sort((a,b)=> Math.abs(a.zh.length-targetLen)-Math.abs(b.zh.length-targetLen));
  } else {
    pool = shuffle(pool);
  }
  return pool;
}

function startGame(fromWrong=false){
  ensureAudio();
  const count = parseInt($("qCount").value,10);

  if (fromWrong){
    const wl = getWrongList();
    if (wl.length===0){ toast("ğŸ‰ ç›®å‰æ²’æœ‰éŒ¯é¡Œï¼"); sfxClick(); return; }
    quiz = [];
    for (let i=0;i<count;i++){
      const w = wl[i % wl.length];
      quiz.push({en:w.en, zh:w.zh, icon:w.icon||autoIcon(w)});
    }
  } else {
    const pool = selectedChapterWords(); // âœ… ä¾ç« ç¯€ï¼ˆæ¯ 20 å–®ï¼‰å–é¡Œåº«ï¼ˆä¿æŒ words.json é †åºåˆ‡ç« ï¼‰
    if (pool.length < 4){ toast("è‡³å°‘éœ€è¦ 4 çµ„å–®å­—æ‰èƒ½å‡ºé¡Œã€‚"); return; }
    quiz = [];
    for (let i=0;i<count;i++) quiz.push( pool[Math.floor(Math.random()*pool.length)] );
  }

  idx=0;
  phase="question";
  nextQuestion();
}

function nextQuestion(){
  current = quiz[idx];
  feedback = {text:"", good:true, t:0};
  shake = {t:0, mag:0};
  answerText = "";
  buildUIForQuestion();

  if ($("mode").value==="listen_pick"){
    if ($("autoSpeak").checked) speak(current.en);
  }
}

function finishOrNext(){
  idx++;
  if (idx>=quiz.length){
    phase="finished";
    ui.buttons = [
      new UIButton({id:"again", x:0,y:0,w:220,h:56, text:"å†ç©ä¸€æ¬¡", icon:"ğŸ®", kind:"primary", onClick:()=>{ sfxClick(); startGame(false);} }),
      new UIButton({id:"wrong", x:0,y:0,w:220,h:56, text:"é‡è€ƒéŒ¯é¡Œ", icon:"ğŸ”", kind:"normal", onClick:()=>{ sfxClick(); startGame(true);} }),
    ];
    layout();
  } else {
    phase="question";
    nextQuestion();
  }
}

function markResult(ok){
  stats.total += 1;
  if (ok){
    stats.correct += 1;
    stats.streak += 1;
    stats.bestStreak = Math.max(stats.bestStreak, stats.streak);
    removeWrongIfExists(current);
  } else {
    stats.streak = 0;
    addWrong(current);
  }
  saveStats();
}

function checkListenPick(selectedWord, btnCenter){
  if (phase!=="question") return;
  const ok = (normalize(selectedWord.en) === normalize(current.en));
  markResult(ok);

  if (ok){
    sfxCorrect();
    if (btnCenter) spawnParticles(btnCenter.x, btnCenter.y, true);
    speak(current.en);
    feedback = {text:`âœ… æ­£ç¢ºï¼ ${current.en} = ${current.zh}`, good:true, t:0.9};
  } else {
    sfxWrong();
    if (btnCenter) spawnParticles(btnCenter.x, btnCenter.y, false);
    shake = {t:0.35, mag:10};
    feedback = {text:`âŒ éŒ¯äº†ã€‚æ­£ç¢ºæ˜¯ï¼š${current.en} = ${current.zh}`, good:false, t:1.1};
  }
  phase="feedback";
  setTimeout(()=>finishOrNext(), 650);
}

function checkCnSpell(){
  if (phase!=="question") return;
  const user = normalize(answerText);
  const ans = normalize(current.en);
  const ok = user === ans;
  markResult(ok);

  if (ok){
    sfxCorrect();
    spawnParticles(W/2, H*0.52, true);
    speak(current.en);
    feedback = {text:`âœ… æ­£ç¢ºï¼ ${current.en} = ${current.zh}`, good:true, t:0.9};
  } else {
    sfxWrong();
    spawnParticles(W/2, H*0.52, false);
    shake = {t:0.35, mag:10};
    const hintLen = Math.min(2, current.en.length);
    feedback = {text:`âŒ éŒ¯äº†ã€‚æ­£ç¢ºï¼š${current.en}ï¼ˆæç¤ºï¼š${current.en.slice(0,hintLen)}...ï¼‰`, good:false, t:1.2};
  }
  phase="feedback";
  setTimeout(()=>finishOrNext(), 720);
}

/* =========================
   7) æ’ç‰ˆ & ç¹ªè£½
   ========================= */
function layout(){
  W = canvas.width; H = canvas.height;

  if (phase==="finished"){
    const btns = ui.buttons;
    const totalW = btns.reduce((s,b)=>s+b.w,0) + (btns.length-1)*12*DPR;
    let x = (W-totalW)/2;
    const y = H*0.62;
    for (const b of btns){
      b.x = x; b.y = y; b.h = 56*DPR; b.w = 220*DPR;
      x += b.w + 12*DPR;
    }
    return;
  }

  if (phase==="question" || phase==="feedback" || phase==="idle"){
    buildUIForQuestion();
  }
}

function buildUIForQuestion(){
  ui.buttons = [];
  const mode = $("mode").value;

  if (!current){
    ui.buttons = [
      new UIButton({id:"start", x:0,y:0,w:260,h:60, text:"é–‹å§‹", icon:"ğŸš€", kind:"primary", onClick:()=>{ sfxClick(); startGame(false);} }),
      new UIButton({id:"wrong", x:0,y:0,w:260,h:60, text:"é‡è€ƒéŒ¯é¡Œ", icon:"ğŸ”", kind:"normal", onClick:()=>{ sfxClick(); startGame(true);} }),
      new UIButton({id:"load", x:0,y:0,w:260,h:60, text:"è¼‰å…¥é¡Œåº«", icon:"ğŸ“¦", kind:"normal", onClick:()=>{ sfxClick(); loadWordsFromSource(); } }),
    ];
    layoutHome();
    return;
  }

  if (mode==="listen_pick"){
    const correctWord = current;
    const distractorWords = pickN(similarPool(correctWord.zh), 3);
    const optWords = shuffle([correctWord, ...distractorWords]);

    const gridW = Math.min(W*0.90, 980*DPR);
    const btnW = (gridW - 14*DPR)/2;
    const btnH = 76*DPR;
    const left = (W-gridW)/2;
    const top = H*0.50;

    for (let i=0;i<4;i++){
      const col = i%2, row = Math.floor(i/2);
      const x = left + col*(btnW + 14*DPR);
      const y = top + row*(btnH + 14*DPR);
      const wObj = optWords[i];
      ui.buttons.push(new UIButton({
        id:"opt"+i, x,y,w:btnW,h:btnH,
        text: wObj.zh,
        icon: wObj.icon || autoIcon(wObj),
        onClick:()=>{
          sfxClick();
          const center = {x: x+btnW/2, y: y+btnH/2};
          checkListenPick(wObj, center);
        }
      }));
    }

    const skip = new UIButton({
      id:"skip", x:0,y:0,w:160,h:52, text:"è·³é", icon:"â­ï¸", kind:"danger",
      onClick:()=>{
        sfxClick();
        markResult(false);
        sfxWrong();
        shake = {t:0.25, mag:8};
        feedback = {text:`â­ï¸ è·³éã€‚æ­£ç¢ºæ˜¯ï¼š${current.en} = ${current.zh}`, good:false, t:0.9};
        phase="feedback";
        setTimeout(()=>finishOrNext(), 520);
      }
    });
    skip.w = 160*DPR; skip.h = 52*DPR;
    skip.x = (W - skip.w)/2;
    skip.y = H*0.79;
    ui.buttons.push(skip);

  } else {
    const check = new UIButton({
      id:"check", x:0,y:0,w:180,h:58, text:"ç¢ºèª", icon:"âœ…", kind:"primary",
      onClick:()=>{ sfxClick(); checkCnSpell(); }
    });
    check.w = 180*DPR; check.h = 58*DPR;
    check.x = (W-check.w)/2;
    check.y = H*0.74;
    ui.buttons.push(check);
  }

  const speakSmall = new UIButton({
    id:"speakSmall", x:0,y:0,w:140,h:44, text:"ğŸ”Š å”¸", icon:"ğŸ—£ï¸", kind:"normal",
    onClick:()=>{ sfxClick(); if(current) speak(current.en); }
  });
  speakSmall.w=140*DPR; speakSmall.h=44*DPR;
  speakSmall.x = W - speakSmall.w - 18*DPR;
  speakSmall.y = 18*DPR;
  ui.buttons.push(speakSmall);
}

function layoutHome(){
  W=canvas.width; H=canvas.height;
  const btns=ui.buttons;
  const y0 = H*0.60;
  for (let i=0;i<btns.length;i++){
    const b = btns[i];
    b.w = 280*DPR; b.h = 62*DPR;
    b.x = (W-b.w)/2;
    b.y = y0 + i*(b.h + 14*DPR);
  }
}

function drawRainbowBand(){
  const y = H*0.12 + Math.sin(tNow*0.7)*10*DPR;
  const amp = 16*DPR;
  const bands = [
    "rgba(255,99,132,.10)",
    "rgba(255,159,64,.10)",
    "rgba(255,205,86,.10)",
    "rgba(75,192,192,.10)",
    "rgba(54,162,235,.10)",
    "rgba(153,102,255,.10)"
  ];
  for (let i=0;i<bands.length;i++){
    ctx.beginPath();
    ctx.moveTo(0, y + i*10*DPR);
    for (let x=0;x<=W;x+=24*DPR){
      const yy = y + i*10*DPR + Math.sin((x/W*6.0)+tNow*0.9+i)*amp*0.08;
      ctx.lineTo(x, yy);
    }
    ctx.lineTo(W, 0);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fillStyle = bands[i];
    ctx.fill();
  }
}

function drawCloud(c){
  ctx.save();
  ctx.globalAlpha = c.a;
  ctx.fillStyle = "#ffffff";
  const x=c.x, y=c.y, s=c.s;
  const r = 22*s;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.arc(x+28*s, y-10*s, r*0.95, 0, Math.PI*2);
  ctx.arc(x+58*s, y, r*1.05, 0, Math.PI*2);
  ctx.arc(x+32*s, y+10*s, r*1.10, 0, Math.PI*2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawBubble(b){
  const [R,G,B] = b.c;
  ctx.save();
  ctx.globalAlpha = b.a;
  const g = ctx.createRadialGradient(b.x-b.r*0.3, b.y-b.r*0.3, b.r*0.2, b.x, b.y, b.r);
  g.addColorStop(0, `rgba(${R},${G},${B},0.55)`);
  g.addColorStop(1, `rgba(${R},${G},${B},0.05)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
  ctx.fill();

  ctx.globalAlpha = b.a*0.7;
  ctx.fillStyle = "rgba(255,255,255,.55)";
  ctx.beginPath();
  ctx.arc(b.x-b.r*0.25, b.y-b.r*0.25, b.r*0.20, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawConfetti(f){
  const [R,G,B] = f.c;
  ctx.save();
  ctx.globalAlpha = f.a;
  ctx.translate(f.x, f.y);
  ctx.rotate(f.rot);
  ctx.fillStyle = `rgba(${R},${G},${B},0.9)`;
  ctx.fillRect(-f.w/2, -f.h/2, f.w, f.h);
  ctx.restore();
}

function drawBackground(){
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,"#1239ff");
  g.addColorStop(0.42,"#22c1f6");
  g.addColorStop(1,"#6ef7c7");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  drawRainbowBand();
  for (const c of bg.clouds) drawCloud(c);
  for (const b of bg.bubbles) drawBubble(b);
  for (const f of bg.confetti) drawConfetti(f);

  const v = ctx.createLinearGradient(0,0,0,H);
  v.addColorStop(0, "rgba(0,0,0,.06)");
  v.addColorStop(1, "rgba(0,0,0,.18)");
  ctx.fillStyle = v;
  ctx.fillRect(0,0,W,H);
}

function updateBackground(dt){
  for (const c of bg.clouds){
    c.x += c.vx * 60*dt * DPR;
    if (c.x > W + 160*DPR) c.x = -220*DPR;
  }

  for (const b of bg.bubbles){
    b.wob += b.wobSp * dt;
    b.x += (b.vx + Math.sin(b.wob)*0.10*DPR) * 60*dt * DPR;
    b.y += b.vy * 60*dt * DPR;
    if (b.y < -b.r-40*DPR) b.y = H + b.r + 40*DPR;
    if (b.x < -b.r-40*DPR) b.x = W + b.r + 40*DPR;
    if (b.x > W + b.r+40*DPR) b.x = -b.r-40*DPR;
  }

  for (const f of bg.confetti){
    f.x += f.vx * 60*dt * DPR;
    f.y += f.vy * 60*dt * DPR;
    f.rot += f.rotSp * dt;
    if (f.y > H + 30*DPR){
      f.y = -30*DPR;
      f.x = rand(0,W);
    }
    if (f.x < -20*DPR) f.x = W + 20*DPR;
    if (f.x > W + 20*DPR) f.x = -20*DPR;
  }
}

function updateParticles(dt){
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life += dt;
    const t = p.life / p.ttl;
    p.x += p.vx * 60*dt * DPR;
    p.y += p.vy * 60*dt * DPR;
    p.vy += (p.good? 0.12:0.18) * 60*dt * DPR;
    if (t>=1) particles.splice(i,1);
  }
}
function drawParticles(){
  for (const p of particles){
    const a = 1 - (p.life/p.ttl);
    ctx.globalAlpha = Math.max(0, a);
    ctx.fillStyle = p.good ? "rgba(110,255,170,1)" : "rgba(255,120,160,1)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r*DPR, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function updateUI(dt){
  for (const b of ui.buttons) b.update(dt);
  if (shake.t>0) shake.t = Math.max(0, shake.t - dt);
  if (feedback.t>0) feedback.t = Math.max(0, feedback.t - dt);
}

function drawUI(){ for (const b of ui.buttons) b.draw(); }

function drawText(){
  const pad = 22*DPR;
  ctx.save();

  if (shake.t>0){
    const k = (shake.t/0.35);
    const mag = shake.mag * k;
    ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag*0.4);
  }

  ctx.fillStyle="rgba(255,255,255,.98)";
  ctx.font = `900 ${Math.floor(30*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
  ctx.textAlign="center"; ctx.textBaseline="top";

  if (phase==="finished"){
    ctx.fillText("ğŸ‰ é—–é—œå®Œæˆï¼", W/2, H*0.20);
    ctx.font = `700 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    ctx.fillStyle="rgba(255,255,255,.80)";
    ctx.fillText("å†ç©ä¸€æ¬¡æˆ–é‡è€ƒéŒ¯é¡Œï¼ŒæŠŠåˆ†æ•¸åˆ·é«˜ï¼", W/2, H*0.28);
    ctx.restore();
    return;
  }

  if (!current){
    ctx.fillText("ğŸ“š è‹±æ–‡å–®å­—é—–é—œ", W/2, H*0.20);
    ctx.font = `700 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    ctx.fillStyle="rgba(255,255,255,.82)";
    ctx.fillText("å…ˆè¼‰å…¥é¡Œåº«ï¼Œå†æŒ‰é–‹å§‹ï¼", W/2, H*0.28);
    ctx.restore();
    return;
  }

  const mode = $("mode").value;
  ctx.font = `800 ${Math.floor(14*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
  ctx.fillStyle="rgba(255,255,255,.86)";
  ctx.textAlign="left";
  ctx.fillText(`ç¬¬ ${idx+1} / ${quiz.length} é¡Œ`, pad, pad);
  ctx.textAlign="right";
  ctx.fillText(`é€£å° ${stats.streak}`, W-pad, pad);

  ctx.textAlign="center";
  ctx.fillStyle="rgba(255,255,255,.98)";

  if (mode==="listen_pick"){
    ctx.font = `900 ${Math.floor(26*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    ctx.fillText("ğŸ§ è½è‹±æ–‡ï¼Œé¸ä¸­æ–‡", W/2, H*0.22);
    ctx.font = `700 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    ctx.fillStyle="rgba(255,255,255,.78)";
    ctx.fillText("ï¼ˆé»å³ä¸Š ğŸ”Š å¯å†å”¸ä¸€æ¬¡ï¼‰", W/2, H*0.27);
  } else {
    ctx.font = `900 ${Math.floor(46*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    const icon = current.icon || autoIcon(current);
    ctx.fillText(`${icon}  ${current.zh}`, W/2, H*0.24);

    const boxW = Math.min(W*0.78, 820*DPR);
    const boxH = 66*DPR;
    const x = (W-boxW)/2;
    const y = H*0.48;

    roundRect(x,y,boxW,boxH,18,"rgba(255,255,255,.14)","rgba(255,255,255,.30)");
    ctx.fillStyle="rgba(0,0,0,.70)";
    ctx.font = `800 ${Math.floor(28*DPR)}px ui-monospace,SFMono-Regular,Menlo,monospace`;
    ctx.textAlign="left"; ctx.textBaseline="middle";
    const shown = answerText.length ? answerText : "ï¼ˆè«‹è¼¸å…¥è‹±æ–‡ï¼‰";
    ctx.globalAlpha = answerText.length ? 1 : 0.55;
    ctx.fillText(shown, x+18*DPR, y+boxH/2);
    ctx.globalAlpha = 1;

    ctx.textAlign="center"; ctx.textBaseline="top";
    ctx.font = `700 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    ctx.fillStyle="rgba(255,255,255,.82)";
    ctx.fillText("è¼¸å…¥å¾ŒæŒ‰ Enter æˆ–é»ã€ç¢ºèªã€", W/2, y+boxH+10*DPR);
  }

  if (feedback.text){
    const bw = Math.min(W*0.86, 980*DPR);
    const bh = 46*DPR;
    const bx = (W-bw)/2;
    const by = H*0.36;
    roundRect(bx,by,bw,bh,16, feedback.good?"rgba(160,255,200,.86)":"rgba(255,170,190,.86)", "rgba(255,255,255,.20)");

    ctx.font = `900 ${Math.floor(20*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
    ctx.fillStyle = feedback.good ? "rgba(0,70,40,.95)" : "rgba(90,0,20,.95)";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(feedback.text, W/2, by+bh/2);
  }

  ctx.restore();
}

/* =========================
   8) ä¸»è¿´åœˆ
   ========================= */
let lastT = performance.now();
function tick(now){
  const dt = Math.min(0.033, (now-lastT)/1000);
  lastT = now;
  tNow = now/1000;

  updateBackground(dt);
  drawBackground();

  updateParticles(dt);
  updateUI(dt);

  drawText();
  drawParticles();
  drawUI();

  if (toastMsg.t>0){
    toastMsg.t = Math.max(0, toastMsg.t - dt);
    drawToast();
  }

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* =========================
   9) äº’å‹•ï¼šæ»‘é¼ /è§¸æ§/éµç›¤
   ========================= */
function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  const x = (("touches" in e) ? e.touches[0].clientX : e.clientX) - rect.left;
  const y = (("touches" in e) ? e.touches[0].clientY : e.clientY) - rect.top;
  return {x: x*DPR, y: y*DPR};
}
function onPress(e){
  ensureAudio();
  const p = getPointerPos(e);
  for (const b of ui.buttons){
    if (b.disabled) continue;
    if (b.contains(p.x,p.y)){
      b.press();
      b.onClick?.();
      break;
    }
  }
}
canvas.addEventListener("mousedown", onPress);
canvas.addEventListener("touchstart", (e)=>{ onPress(e); }, {passive:true});

window.addEventListener("keydown", (e)=>{
  if ($("mode").value !== "cn_spell") return;
  if (!current || phase!=="question") return;

  const active = document.activeElement;
  if (active && (active.tagName==="TEXTAREA" || active.tagName==="INPUT")) return;

  if (e.key === "Enter"){
    sfxClick();
    checkCnSpell();
    return;
  }
  if (e.key === "Backspace"){
    answerText = answerText.slice(0,-1);
    return;
  }
  if (e.key.length===1){
    const ch = e.key;
    if (/^[a-zA-Z\- ]$/.test(ch)) answerText += ch;
  }
});

/* =========================
   10) HTML æ§åˆ¶åˆ—
   ========================= */
$("startBtn").onclick = ()=>{ sfxClick(); startGame(false); };
$("retryWrongBtn").onclick = ()=>{ sfxClick(); startGame(true); };
$("speakBtn").onclick = ()=>{ sfxClick(); if (current) speak(current.en); };
$("showWrongBtn").onclick = ()=>{
  sfxClick();
  const list = getWrongList();
  if (list.length===0){ toast("ç›®å‰æ²’æœ‰éŒ¯é¡Œã€‚"); return; }
  const top = list.slice(0,50).map((w,i)=>`${i+1}. ${w.en} = ${w.zh}ï¼ˆéŒ¯${w.wrongCount}æ¬¡ï¼‰`).join("\n");
  alert(`éŒ¯é¡Œæœ¬ï¼ˆå‰${Math.min(50,list.length)}é¡Œï¼‰ï¼š\n\n${top}${list.length>50 ? "\n\n...ï¼ˆé‚„æœ‰æ›´å¤šï¼‰" : ""}`);
};
$("resetStatsBtn").onclick = ()=>{
  sfxClick();
  stats = {total:0, correct:0, streak:0, bestStreak:0};
  localStorage.setItem(STATS_KEY, JSON.stringify(stats));
  renderPills();
  toast("å·²æ¸…é™¤æˆç¸¾ã€‚");
};

$("mode").onchange = ()=>{ sfxClick(); layout(); };
$("chapter").onchange = ()=>{ sfxClick(); updateWordCount(); };
$("qCount").onchange = ()=>{ sfxClick(); };
$("difficulty").onchange = ()=>{ sfxClick(); };

$("lexSource").onchange = ()=>{ sfxClick(); updateWordCount(); };
$("loadWordsBtn").onclick = ()=>{ sfxClick(); loadWordsFromSource(); };

/* =========================
   11) Toast
   ========================= */
let toastMsg = {text:"", t:0};
function toast(text){ toastMsg = {text, t:1.8}; }
function drawToast(){
  if (!toastMsg.text || toastMsg.t<=0) return;
  const a = clamp(toastMsg.t/1.8,0,1);
  ctx.globalAlpha = 0.9 * a;
  const w = Math.min(W*0.86, 920*DPR);
  const h = 48*DPR;
  const x = (W-w)/2;
  const y = H - h - 18*DPR;
  roundRect(x,y,w,h,16,"rgba(255,255,255,.80)","rgba(0,0,0,.18)");
  ctx.fillStyle="rgba(0,0,0,.78)";
  ctx.font = `800 ${Math.floor(16*DPR)}px system-ui,-apple-system,"Noto Sans TC",sans-serif`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText(toastMsg.text, W/2, y+h/2);
  ctx.globalAlpha=1;
}

/* =========================
   12) è‡ªæˆ‘æ¸¬è©¦ï¼ˆä¸å½±éŸ¿éŠæˆ²ï¼›å¤±æ•—æœƒåœ¨ console.errorï¼‰
   ========================= */
function assert(cond, msg){ if(!cond) throw new Error("SelfTest: " + msg); }
function runSelfTests(){
  try{
    assert(normalize(" Apple ") === "apple", "normalize should trim/lower");
    assert(autoIcon({en:"apple"}) === "ğŸ", "autoIcon apple");
    const v = validateWordList([{en:"a",zh:"ä¸­"},{en:"b",zh:"ä¸­"},{en:"c",zh:"ä¸­"},{en:"d",zh:"ä¸­"}]);
    assert(Array.isArray(v) && v.length===4, "validateWordList basic");
    const csv = parseCsvToWords("apple,è˜‹æœ,ğŸ\ncat,è²“\n");
    assert(csv.length===2 && csv[0].icon==="ğŸ", "parseCsvToWords icon optional");
    console.log("âœ… SelfTests passed");
  }catch(e){
    console.error(e);
  }
}

/* =========================
   13) åˆå§‹åŒ–
   ========================= */
function init(){
  current = null;
  phase = "idle";
  buildUIForQuestion();
  resize();
  layout();
  initBackground();
  runSelfTests();
}
init();
layout();
</script>
</body>
</html>
